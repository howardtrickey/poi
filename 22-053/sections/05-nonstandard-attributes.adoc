
[[ug_nonstandard_attributes_section]]
== Payload: Nonstandard Attributes

An _attribute_ is a named property of a feature. While this POI Conceptual Model Standard specifies some standard attributes (e.g., lifetime attributes), most applications will need to define and use some attributes that are not normatively defined by the standard. The mechanism for including non-standard attributes in a POI is to use the *hasPayload* property, whose type is zero or more *POI_Payload* values.

=== Using POI_Payload

A *POI_Payload* is only partially specified in this POI Conceptual Model Standard. These properties are specified:

usesSchema:: The value identifies a _schema_ for the payload. How this identification is done and what the schema looks like depends on the implementation technology used. We'll see some examples below. The schema describes the _syntax_ for the other properties of the payload, and the value for identifying the schema is typically a _URI_. There can be more than one schema, but the intent is that these will represent the same conceptual model of a payload, perhaps for different implementation technologies.

hasDefinition:: The value is a companion to the schema referenced by *usesSchema*, and it describes the _semantics_ of the various payload fields. Typically, this will be plain text descriptions of the properties, what standards they adhere to, etc.

hasFeatureOfInterest:: This indicates the Feature of Interest that the payload is for. There can be zero or more of these.

For example, suppose an application needed an attribute called *isPublic*, whose value is true or false depending on whether or not the POI is something the general public can visit. A particular POI could include a *hasPayload* association to a *POI_Payload* that looks like this in conceptual form:


[cols="1,2,3"]
|===
|*Attribute*|*Value type and multiplicity*|*Definition*

|usesSchema
|PayloadSchema [1..*]
|Refers to the schema(s) for this payload
|hasDefinition
|PayloadDefinition [0..1]
|Refers to the definition of the payload attributes
|isPublic
|Boolean [1..1]
|Is this POI a publicly visitable place
|===

Both *PayloadSchema* and *PayloadDefinition* should be a *Link*.

Suppose the implementation technology is JSON. Here is how the above payload might be used in a POI expressed in JSON:

.POI Example of a POI with a POI_Payload (JSON)
[source,JSON]
----
   {
      "type": "Feature",
      "geometry": {"type": "Point", "coordinates": {45.14, -94.69}},
      "featureID": 693842,
      "name": {"name" : "Midtown Library"},
      "contactInfo" : {"role": "city representative"},
      "hasPayload": [
         "usesSchema" : [
            {
               "href" : "https://example.org/schema/egpoi.json",
               "rel" : "describedby"
            }
         ],
         "hasDefinition" : {
               "href" : "https://example.org/schemadef/egpoi",
               "rel" : "type"
         },
         "isPublic:" : true
      ]
   }
----

The value of the *usesSchema* property should reference a schema that might look like this:

.POIProperty Example Payload Schema (JSON)
[source,JSON]
----
  {
    "$schema": "http://json-schema.org/draft/2020-12/schema#",
    "$id": "https://example.org/schema/egpoi.json",
    "title": "POI Payload for POI with IsPublic property",
    "typee": "object",
    "properties": {
      "isPublic": { "type": "boolean"}
    }
  }
----

The value of the *hasDefinition" property should reference a file that describes the semantics corresponding to the above schema. It might look something like this:

.POIProperty Example Payload Schema (JSON)
[source]
----
  isPublic: This field is a boolean that should be true if the POI is publicly visitable, else false.
----

=== Recommended Schema and Semantics for Common Nonstandard Attributes

There are a number of attributes that commonly are needed in use cases for POIs yet are not standardized in the POI-CM. This section suggests a recommended schema for these common nonstandard attributes.

==== Address ====

An address is a structured or semi-structured way of expressing where a place on earth can be found, usually referencing political areas, route (street) names, and numbers on routes. These are the things one uses to specify where mail is to be delivered, or packages are to be picked up. Special software called _geocoders_ can convert an address into (latitude, longitude) position on earth.

There are many addressing systems in use in the world. A schema to represent them all precisely would be quite complicated.  The recommendation here is to use a modification of *CI_Address* class from the ISO 19115 (Citation Information) standard.
The modification is to allow cardinality of all the text strings to be more than 1 if desired: this allows for multiple languages to be used.

.Address Schema
[source,JSON]
----
    "Address" {
        "administrativeArea": "CharacterString" [0..],
        "city": "CharacterString" [0..],
        "country": "CharacterString" [0..],
        "deliveryPoint": "CharacterString" [0..],
        "electronicMailAddress": "CharacterString" [0..],
        "postalCode": "CharacterString" [0..]
        }
----

where the *country*, *adminstrativeArea* (state or province), and *city* give a structuring of three of the political areas containing the POI, and the *postalCode* is the postal or zipcode that some countries use in addresses (varies by country). The *deliveryPoint* is an unstructured way of expressing the rest of the address. E.g., it might be "123 Main St., Unit 3" or "Market Square". 
If there are not multiple CharacterStrings for the properties, then the language of the address should be either a common language implicit in the entire dataset (e.g., English), or a language in use in the country in question.
For international datasets, it is recommended that the language of each string in the address be annotated with its language, using the facilities available in the particular implementation technology used.

For example, if the implementation technology is JSON, this could be the way to express the address of the Empire State Building in several languages:

.Example Address Value
[source,JSON]
----
    {
      "administrativeArea": [
         
      ]
    }
----

// _TODO: check out ISO 19160:1 A conceptual model for addressing_

==== Telephone Number

The telephone number is the number to use to contact the POI to ask questions, get service, etc. The recommendation here is to use the *CI_Telephone* class from the Informative Annex:

.CI_Telephone Schema
[source,JSON]
----
    "CI_Telephone": {
        "number": "CharacterString" [1..1],
        "numberType": "CI_TelephoneTypeCode" [0..1]
        }
----

where the *number* contains the dial numerals needed to reach that place. The _ITU-T E.164 standard_ (https://www.itu.int/rec/T-REC-E.164[ref]) specifies a suitable format for telephone numbers. It starts with a recommended *+* sign, followed by up to fifteen digits (with no spaces or other punctuation). The digits will typically be a country code, then an area code, then a local number. For example, the US local number 555-1234 with an area code of 212 would be represented by this character string:

.ITU-T E.164 Telephone Number
[source,text]
----
   +12125551234
----

The optional *numberType* is a one of *facsimile*, *sms*, *voice*, where *voice* is the default if the *numberType* is left out.

==== Opening Hours

The previous section described the state of current practices for business categories.
There is a choice between a simple standard like the schema.org method, or the more expressive Calendar Availability standard.
The increased expressability of the Calendar Availability standard comes at the expense of verboseness, so implementers might like a choice between the two standards.

A suggested conceptual model for Opening Hours that offers the choice between the above two standards is:

.Recommended Opening Hours Schema
[source,json]
----
    "OpeningHours": {
        "openingHoursLines": "CharacterString" [0..],
        "openingHoursFormat": "OpeningHoursFormatCode" [0..1]
        }
----

where *OpeningHoursFormatCode* is a *CodeList* with literals *schemadotorg* and *icalendaravailability*, with the default being *schemadotorg*. Note that while technically the Calendar Availability value is one string, it is inconvenient to deal with such a long value (with line breaks) in JSON, so it is convenient to have the value be a sequence of strings that represent lines to be concatenated together, with line breaks between them, in order to form the actual specification string.  Similarly,  the schema.org format, multiple lines are convenient to be able to represent different weekday ranges that have differing time ranges.

==== Category

The previous section described the state of current practices for business categories.
None of them is comprehensive enough or granular enough to serve the use case of "I'm looking for a POI that offers this product, service or experience" for the full range of things people need to find. In the absence of anything better, the NAICS list seems best and the recommendation would be to use that as the code list. However, in order to allow for ultimate flexibility, the following schema is recommended.:

.Recommended Category Schema
[source,json]
----
    "category": {
        "category": "CharacterString" [0..1],
        "categorySystem": "CategorySystemCode" [0..1]
        }
----

where *CategorySystemCode* is a *CodeList* with literals *naics*, *osm*, *ogcindoor*, *geonames*, and *custom*, where *custom* is the default if none is listed, and means that the category system is basically freeform (recommended as English language text).


